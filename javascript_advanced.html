<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gihyeon's Blog</title>
    <link rel="stylesheet" href="javascript_advanced.css" />
</head>

<body>
    <div class="upper_center_arrangement">
        <h1>Gihyeon's Blog</h1>

        <h2 id="h2-title">
            블록체인 관련 끄적끄적...
        </h2>
    </div>

    <form action="index.html" method="get">
        <p>
            <button type="submit" class="large-button">홈</button>
        </p>
    </form>

    <form action="blockchain concept.html" method="get">
        <p>
            <button type="submit" class="large-button">1주차 정리본</button>
        </p>
    </form>

    <form action="web.html" method="get">
        <p>
            <button type="submit" class="large-button">2주차 정리본</button>
        </p>
    </form>

    <form action="javascript.html" method="get">
        <p>
            <button type="submit" class="large-button">3주차 정리본</button>
        </p>
    </form>

    <ul>
        <p>
            <li><a href="#higher order function">고차 함수</a></li>
        </p>
    </ul>

    <ul>
        <p>
            <li><a href="#object oriented programming">객체 지향 프로그래밍</a></li>
        </p>
    </ul>

    <ul>
        <p>
            <li><a href="#asynchronous">비동기</a></li>
        </p>
    </ul>

    <section id="higher order function"></section>
    <h2>일급 객체</h2>
    <div class="section">
        <ul>
            <li>변수에 할당 할 수 있다.</li>
            <li>다른 함수의 전달인자로 전달될 수 있다.</li>
            <li>다른 함수의 결과로써 리턴될 수 있다.</li>
        </ul>
    </div>

    <!-- 2/24 -->

    <h2>고차 함수(higher order function)</h2>
    <div class="section">
        <ul>
            <li>함수를 전달인자로 받을 수 있고, 함수를 리턴할 수 있는 함수</li>
            <li>콜백 함수: 다른 함수의 전달인자로 전달되는 함수</li>
            <li>콜백 함수를 전달받은 고차 함수는, 함수 내부에서 이 콜백 함수를 ‘호출’할 수 있고, 조건에 따라 콜백 함수의 ‘실행 여부’를 결정할 수도 있다.</li>
        </ul>
    </div>

    <div class="section">
        <h3>내장 고차 함수 - filter 활용 예시</h3>
        <ul>
            <li>filter 메서드: 모든 배열의 요소 중에서 특정 조건을 만족하는 요소를 걸러내는 메서드</li>
            <li>콜백 함수의 내부 조건에 따라 참 또는 거짓을 리턴한다.</li>
        </ul>

        <h3>내장 고차 함수 - map 활용 예시</h3>
        <ul>
            <li>배열의 각 요소가 특정 논리(함수)에 의해 다른 요소로 지정(map) 된다.</li>
        </ul>

        <h3>내장 고차 함수 - reduce 활용 예시</h3>
        <ul>
            <li>배열의 각 요소를 특정 방법(함수)에 따라 원하는 하나의 형태로 응축한다.</li>
        </ul>
    </div>

    <h2>고차 함수의 중요성</h2>
    <div class="section">
        <ul>
            <li>추상화: 복잡한 어떤 것을 압축해서 핵심만 추출한 상태로 만드는 것 => 생산성의 향상</li>
        </ul>
    </div>

    <!-- 2/25 -->

    <section id="object oriented programming"></section>

    <h2>객체 지향 프로그래밍(OOP)</h2>
    <div class="section">
        <ul>
            <li>하나의 모델이 되는 청사진(blueprint)을 만들고, 그 청사진을 바탕으로 한 객체(object)를 만드는 프로그래밍 패턴</li>
        </ul>

        <h3>청사진 - class</h3>
        <h3>객체 - instance</h3>

        <ul>
            <li>일반적인 다른 함수와 구분하기 위해 ‘클래스’는 보통 ‘대문자’로 시작하며 일반명사로 만든다.</li>
            <li>일반적인 함수는 적절한 동사를 포함하고 ‘소문자’로 시작한다.</li>
        </ul>

    </div>
    <h2>속성과 메서드</h2>
    <div class="section">
        <ul>
            <li><strong>속성:</strong> 객체에 따른 특징</li>
            <li><strong>메서드:</strong> 객체에 딸린 함수</li>
        </ul>
    </div>

    <h2>this</h2>
    <div class="section">
        <ul>
            <li>인스턴스 객체</li>
        </ul>
    </div>

    <h2>객체(Object)란?</h2>
    <div class="section">
        <ul>
            <li>객체는 속성과 메서드를 가진 데이터 구조이다.</li>
            <li>자바스크립트에서 객체는 {}를 사용해 만들 수 있다.</li>
        </ul>
    </div>

    <h2>인스턴스(Instance)란?</h2>
    <div class="section">
        <ul>
            <li>"인스턴스는 특정 클래스에서 생성된 객체”이다.</li>
        </ul>
    </div>

    <h2>Method</h2>
    <div class="section">
        <ul>
            <li>클래스의 인스턴스에서 실행되는 함수</li>
        </ul>
    </div>

    <h2>용어 정리</h2>
    <div class="section">
        <ul>
            <li><strong>prototype:</strong> 모델의 청사진을 만들 때 쓰는 원형 객체</li>
            <li><strong>constructor:</strong> 인스턴스가 초기화될 때 실행하는 생성자 함수</li>
            <li><strong>this:</strong> 함수가 실행될 때, 해당 scope마다 생성되는 고유한 실행 context, new 키워드로 인스턴스를 생성했을 때에는, 해당 인스턴스가
                바로 this의 값이 됨</li>
        </ul>
    </div>

    <h2>객체 지향 프로그래밍의 주요 개념</h2>
    <div class="section">
        <h3>캡슐화</h3>
        <ul>
            <li>데이터(속성)와 기능(메서드)을 하나의 객체 안에 넣어서 묶는 것</li>
            <li>내부 데이터나 내부 구현이 외부로 노출되지 않도록 만드는 것</li>
        </ul>

        <h3>추상화</h3>
        <ul>
            <li>내부 구현은 아주 복잡한데, 실제로 노출되는 부분은 단순하게 만든다는 개념</li>
        </ul>

        <h3>상속</h3>
        <ul>
            <li>부모 클래스의 특징을 자식 클래스가 물려받는 것</li>
        </ul>

        <h3>다형성</h3>
        <ul>
            <li>하나의 메서드나 클래스가 다양한 형태를 가질 수 있다.</li>
        </ul>
    </div>

    <h2>객체 지향 언어들의 차이점</h2>
    <div class="section">
        <ul>
            <li>은닉화(private 키워드)의 한계</li>
            <li>추상화(interface 키워드) 기능의 부재</li>
        </ul>
    </div>

    <h2>프로토타입(Prototype)</h2>
    <div class="section">
        <ul>
            <li>JavaScript는 프로토타입 기반 언어이다.</li>
            <li>프로토타입은 ‘원형 객체’를 의미한다.</li>
        </ul>
    </div>
    </div>

    <!-- 2/26 -->

    <section id="asynchronous"></section>
    <h2>Read Me - 비동기</h2>
    <div class="section">
        <h3>블로킹</h3>
        <ul>
            <li>하나의 작업이 끝날 때까지 이어지는 작업을 막는 것</li>
        </ul>
    </div>

    <h2>비동기적 실행 예시</h2>
    <div class="section">
        <ul>
            <li>백그라운드 실행, 로딩 창 등의 작업</li>
            <li>인터넷으로 서버로 요청을 보내고, 응답을 기다리는 작업</li>
            <li>큰 용량의 파일을 로딩하는 작업</li>
        </ul>
    </div>

    <h2>동기 & 비동기</h2>
    <div class="section">
        <h3>동기(synchronous)</h3>
        <ul>
            <li>특정 코드의 실행이 완료될 때까지 기다리고 난 후 다음 코드를 수행하는 것</li>
        </ul>
        <h3>비동기(asynchronous)</h3>
        <ul>
            <li>특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드들을 수행하는 것</li>
        </ul>
    </div>

    <h2>JavaScript의 작동원리</h2>
    <div class="section">
        <ul>
            <li>싱글 스레드 기반으로 동작하는 언어(한 번에 하나의 작업만 처리할 수 있다) -> 기본적으로 동기적으로 코드 실행</li>
            <li>JavaScript는 비동기 처리를 지원 -> 런타임 환경이 함께 협력하여 비동기 작업을 처리하기 때문</li>
        </ul>
    </div>

    <h2>비동기로 작동하는 코드를 제어할 수 있는 방법: Callback</h2>
    <div class="section">
        <ul>
            <li>callback 함수를 통해 비동기 코드의 순서를 제어할 수 있다 -> 비동기를 동기화할 수 있다.</li>
        </ul>
        <h3>Callback hell</h3>
        <ul>
            <li>callback 함수를 통해 비동기 코드의 순서를 제어할 수 있지만 코드가 길어질수록 복잡해지고 가독성이 낮아지는 단점이 있다.</li>
        </ul>
    </div>

    <h2>비동기로 작동하는 코드를 제어할 수 있는 방법: Promise</h2>
    <div class="section">
        <h3>new Promise</h3>
        <ul>
            <li>Promise는 class이기 때문에 ‘new’ 키워드를 통해 Promise 객체를 생성한다.</li>
            <li>Promise는 비동기 처리를 수행할 콜백 함수(executor)를 인수로 전달받는다.</li>
            <li>콜백 함수는 resolve, reject 함수를 인수로 전달받으며 자동 실행된다.</li>
            <li>코드가 정상적으로 처리되면 ‘resolve 함수’를 호출하고, 에러 발생 시 ‘reject 함수’를 호출한다.</li>
        </ul>
    </div>

    <h2>내부 프로퍼티</h2>
    <div class="section">
        <h3>State</h3>
        <ul>
            <li>기본 상태는 pending(대기), 성공 시 fulfilled(이행), 에러 발생 시 rejected(거부)</li>
        </ul>
        <h3>Result</h3>
        <ul>
            <li>초기 상태는 undefined, resolve(value) 호출 시 value로, reject(error) 호출 시 error로 변경</li>
        </ul>
    </div>

    <h2>Then, Catch, Finally</h2>
    <div class="section">
        <h3>Then</h3>
        <ul>
            <li>resolve 함수가 호출되면 .then 메서드로 접근 가능</li>
            <li>Promise를 반환하면 다음 .then의 콜백 함수로 result 전달</li>
        </ul>
        <h3>Catch</h3>
        <ul>
            <li>reject 함수가 호출되면 .catch 메서드로 접근 가능</li>
        </ul>
        <h3>Finally</h3>
        <ul>
            <li>정상 처리 여부와 상관없이 .finally 메서드로 접근 가능</li>
        </ul>
    </div>

    <h2>Promise Chaining</h2>
    <div class="section">
        <ul>
            <li>비동기 작업을 순차적으로 진행해야 할 경우 사용</li>
        </ul>
    </div>

    <h2>비동기로 작동하는 코드를 제어할 수 있는 방법: Promise.all()</h2>
    <div class="section">
        <ul>
            <li>여러 개의 비동기 작업을 동시에 처리할 때 사용</li>
            <li>인자로 배열을 받으며, 모든 Promise가 정상적으로 처리되면 결과를 배열로 저장하여 새로운 Promise 반환</li>
            <li>하나라도 에러 발생 시 즉시 종료</li>
        </ul>
    </div>

    <h2>Async / Await</h2>
    <div class="section">
        <ul>
            <li>함수 앞에 async 키워드를 사용하고, async 함수 내에서만 await 키워드를 사용</li>
            <li>await 키워드가 작성된 코드가 실행된 후 다음 코드 실행</li>
        </ul>
    </div>

    <h2>Node.js</h2>
    <div class="section">
        <ul>
            <li>JavaScript를 사용하여 서버 사이드 애플리케이션을 개발할 수 있게 해주는 런타임 환경</li>
        </ul>
        <h3>Node.js 내장 모듈을 사용하는 방법</h3>
        <ul>
            <li>모든 모듈은 require 구문을 이용하여 불러와야 함</li>
        </ul>
        <h3>3rd-party 모듈을 사용하는 방법</h3>
        <ul>
            <li>공식 제공하는 빌트인 모듈이 아닌 모든 외부 모듈</li>
            <li>npm을 사용하여 다운로드 (Ex: npm install ...)</li>
        </ul>
    </div>

    <h2>fetch API</h2>
    <div class="section">
        <ul>
            <li>URL로 요청을 보낼 수 있는 API</li>
        </ul>
    </div>

    <h2>Axios</h2>
    <div class="section">
        <ul>
            <li>브라우저를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리</li>
        </ul>
        <h3>Axios 사용법</h3>
        <ul>
            <li>npm install axios</li>
        </ul>
        <h3>GET 요청</h3>
        <ul>
            <li>일반적으로 정보를 요청하기 위해 사용</li>
        </ul>
        <h3>POST 요청</h3>
        <ul>
            <li>서버에 데이터를 보내기 위해 사용</li>
        </ul>
    </div>



    <div class="below"></div>

    <div class="below_box">
        &copy; 2025 GiHyeon's Blog
        <p>All rights reserved</p>
    </div>
</body>

</html>