<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gihyeon's Blog</title>
    <link rel="stylesheet" href="blockchain.css" />
</head>



<body>
    <div class="upper_center_arrangement">
        <h1>Gihyeon's Blog</h1>

        <h2 id="h2-title">
            블록체인 관련 끄적끄적...
        </h2>
    </div>

    <form action="index.html" method="get">
        <p>
            <button type="submit" class="large-button">홈</button>
        </p>
    </form>

    <form action="web.html" method="get">
        <p>
            <button type="submit" class="large-button">2주차 정리본</button>
        </p>
    </form>

    <form action="javascript.html" method="get">
        <p>
            <button type="submit" class="large-button">3주차 정리본</button>
        </p>
    </form>

    <ul>
        <p>
            <li><a href="#home">홈</a></li>
        </p>
        <p>
            <li><a href="#blockchain structure">블록체인 구조와 특징</a></li>
        </p>
        <p>
            <li><a href="#bitcoin concept">비트코인 특징</a></li>
        </p>
        <p>
            <li><a href="#distributed ledger">분산 원장</a></li>
        </p>
        <p>
            <li><a href="#ethereum">이더리움</a></li>
        </p>
    </ul>


    <!-- 2/3 -->

    <h2>블록체인 구조와 특징</h2>

    <h3>해시, 디지털 서명, ISMS</h3>

    <h4>사이버펑크 선언문</h4>
    <ul>
        <li>무언가를 숨기기 위해서는 암호화와 암호화된 서명이 필요하다.</li>
        <li>정보는 이용 가능한 저장 공간을 채우기 위해서 확장되어 왔다.</li>
        <li>지식은 합의를 필요로 한다. 정보는 암호화될 수 없다.</li>
        <li>사이버펑크는 코드를 사용한다.</li>
        <li>비밀을 보호하기 위해서 소프트웨어를 사용한다.</li>
        <li>사이버펑크는 암호학에서의 규제를 비판한다.</li>
        <li>사이버펑크는 익명 체계를 만들어냈으며, 익명과 디지털 서명 그리고 전자 돈을 사용해서 비밀을 막아왔다.</li>
    </ul>

    <h3>Before going in…</h3>
    <ul>
        <li>블록체인 => 혁신적인 기술? 탈중앙화? 무결성? 제일 중요한 것은 ‘신뢰’이다.</li>
        <li>블록체인 &lt;=&gt; 신뢰</li>
    </ul>

    <h3>비트코인은 최초의 블록체인이 아니다?</h3>
    <ul>
        <li>최초의 블록체인 아이디어: 디지털 문서의 타임 스탬프를 보장하기 위한 아이디어</li>
        <li>1989년 연구 결과 조작 스캔들 발생</li>
        <li>디지털 기록의 불변성 연구 시작</li>
        <li>블록이라는 단위에 데이터 저장</li>
        <li>블록이 순서를 가지고 연결됨</li>
    </ul>

    <h2>화폐의 역사</h2>

    <h3>실물 화폐</h3>
    <ul>
        <li>물건이 지니는 가치가 교환할 때마다 달라진다.</li>
        <li>서로의 요구사항이 맞지 않으면 물물교환 불가능.</li>
        <li>조선시대 실물화폐: 쌀</li>
        <li>실물화폐의 문제점:
            <ul>
                <li>내구성이 없음</li>
                <li>상품의 질이 다름</li>
                <li>휴대성이 없음</li>
            </ul>
        </li>
    </ul>

    <h3>금속화폐 & 지폐</h3>
    <ul>
        <li>기술 발전으로 모든 금속화폐를 공급하기 어려워짐</li>
        <li>금속 부족으로 종이가 개발됨</li>
    </ul>

    <h3>신용 화폐</h3>
    <ul>
        <li>국가의 신뢰를 바탕으로 하는 화폐</li>
        <li>신용화폐는 중앙기관의 통제가 필요함</li>
    </ul>

    <h3>화폐가 가지는 특성 5가지</h3>
    <ul>
        <li>휴대성</li>
        <li>가분성</li>
        <li>내구성</li>
        <li>동질성</li>
        <li>가치의 안정성</li>
    </ul>

    <h3>화폐의 3대 기능</h3>
    <ul>
        <li>교환의 매개체</li>
        <li>가치 척도의 기능</li>
        <li>가치 저장 기능</li>
    </ul>

    <h3>화폐의 기능으로 본 암호화폐</h3>
    <ul>
        <li>교환의 매개체로 부족</li>
        <li>가치 척도 기능 부족</li>
        <li>가치 저장 수단으로 사용</li>
    </ul>

    <h3>신용 창출 (Credit Creation)</h3>
    <ul>
        <li>은행을 통해 화폐 총량이 증가하는 현상</li>
        <li>본원통화와 지급준비금 개념</li>
    </ul>

    <h3>세계 금융 위기</h3>
    <ul>
        <li>서브프라임 모기지 사태로 인한 연쇄 파산</li>
        <li>금융 회사들의 파산</li>
    </ul>

    <h3>양적 완화</h3>
    <ul>
        <li>미국 연방준비제도의 경기 부양 정책</li>
        <li>금리 인하 및 유동성 공급</li>
    </ul>

    <h3>양적 완화 리스크</h3>
    <ul>
        <li>자산 가격 버블</li>
        <li>인플레이션 위험</li>
        <li>부의 양극화</li>
    </ul>

    <h3>암호화폐의 등장 (비트코인)</h3>
    <ul>
        <li>중앙화 시스템의 문제점 인식</li>
        <li>탈중앙화 금융의 대안 제시</li>
    </ul>

    <h3>사이버 펑크 (Cypherpunk)</h3>
    <ul>
        <li>프라이버시 보호 운동</li>
        <li>닉 재보, 웨이 다이 등의 기여</li>
    </ul>

    <h3>사토시 나카모토의 등장</h3>
    <ul>
        <li>비트코인 백서 발표 (2008)</li>
        <li>제네시스 블록 채굴 (2009)</li>
        <li>중앙화 금융 시스템에 대한 비판</li>
    </ul>

    <!-- 2/4 -->

    <section id="blockchain structure">
        <h2>해시의 역할은 데이터의 무결성을 증명하는 것이다.</h2>
    </section>

    <h3>Before going in…</h3>

    <p>스튜어트 하비와 스콧 스토네타가 고안한 블록체인은 암호화폐를 위한 것이 아닌 디지털 문서에 보장된 타임 스탬프를 찍기 위함이다.</p>

    <h3>해시(Hash) - 타임 스탬프</h3>

    <h4>해시(Hash)란?</h4>
    <ul>
        <li>데이터를 압축한 고정된 크기의 출력값(해시 값)이 파일이다.</li>
        <li>해시는 주로 ‘데이터의 무결성’을 확인하거나 ‘암호학적 보안’을 제공하는 데 사용된다.</li>
    </ul>

    <h4>타임 스탬프 해시 과정</h4>
    <ul>
        <li><strong>1. 데이터 준비</strong> => 타임스탬프를 부여하려는 디지털 데이터 준비(Ex: txt, jpg…)</li>
        <li><strong>2. 데이터의 해시 값 생성</strong> => 암호학적 해시 함수(Hash Function) 적용 => 해시 함수는 데이터를 고정된 길이의 ‘해시 값’으로 변환한다.
        </li>
        <ul>
            <li>입력 데이터가 어떤 크기이든 상관없이 고정된 크기의 해시 값으로 압축된다.</li>
            <li>데이터가 조금이라도 변경되면 완전히 다른 해시 값이 생성된다.</li>
        </ul>
        <li><strong>3. 해시 값을 타임스탬프 기관(Timestamp Authority, TSA)에 제출</strong> => 타임스탬프 기관은 논문 상에서 “신뢰할 수 있는 제 3자가 해시를
            서명하고, 시간 정보를 포함하여 문서의 유효성을 보장”한다고 설명한다.</li>
        <ul>
            <li>TSA의 기능</li>
            <ul>
                <li>해시 값을 기록: 데이터의 원본 대신 해시 값만 저장하여 프라이버시를 보장</li>
                <li>타임스탬프 추가: 현재 날짜와 시간 정보를 해시 값과 결합</li>
                <li>디지털 서명: 타임스탬프 정보에 디지털 서명을 추가하여 데이터의 ‘무결성’과 ‘신뢰성’을 보장한다</li>
            </ul>
        </ul>
        <li><strong>4. 타임 스탬프와 해시 값 반환</strong> => TSA는 사용자가 제출한 해시 값에 타임스탬프와 서명을 추가한 결과를 사용자에게 반환한다.</li>
        <li><strong>5. 데이터 검증 방법</strong> => 데이터의 타임스탬프의 검증 방법: 원본 데이터의 해시 값을 다시 계산(SHA-256으로 자신의 데이터를 해싱) => 계산한 해시
            값과
            TSA가 발행한 타임스탬프의 해시 값을 비교한다.</li>
        <ul>
            <li>해시가 동일? 데이터 변조 X</li>
            <li>해시가 동일 X? 데이터 변조 or 변경</li>
        </ul>
        <li><strong>6. 타임스탬프의 블록체인 활용</strong> => 각 해시 값은 이전 해시와 연결되어서 체인을 형성한다.</li>
        <ul>
            <li>각 타임스탬프가 이전 타임스탬프의 해시 값을 포함하도록 설계 => 이렇게 하면 시간 순서가 기록되며, 이전 데이터의 무결성을 보장</li>
        </ul>
    </ul>

    <h3>해시 함수(Hash Function)</h3>

    <h4>해시 생성 방법: 해시 함수(Hash Function)이용</h4>
    <ul>
        <li><strong>해시 함수</strong>: 임의의 길이를 가진 입력 데이터를 ‘고정된 길이’의 해시 값으로 매핑하는 함수</li>
        <li><strong>SHA-256 알고리즘</strong>: 어떤 입력값을 넣어도 256 비트 길이의(64자)의 값을 출력함</li>
        <li><strong>SHA-1 알고리즘</strong>: 160 비트 길이의(40자)의 값을 출력함</li>
    </ul>

    <h4>해시 함수의 특징</h4>
    <ul>
        <li><strong>1. 고정된 출력 길이</strong>: 모든 암호학적 해시 함수는 입력 데이터의 크기와 관계없이 고정된 길이의 출력(해시 값)을 생성한다.</li>
        <li><strong>2. 충돌 회피</strong>: 서로 다른 입력 데이터가 동일한 해시 값을 가질 확률은 극도로 낮다.</li>
        <li><strong>3. 역상 저항성(Preimage Resistance)</strong>: 해시 값을 통해 원래 입력값을 역으로 계산하는 것이 계산적으로 불가능</li>
        <li><strong>4. 효율성</strong>: 현대 컴퓨터에서 빠르게 계산 가능(긴 데이터를 넣어도 결과를 빠르게 확인 가능)</li>
        <li><strong>5. 강력한 보안성</strong>: 현재까지 실직적인 공격이 매우 어려움</li>
    </ul>

    <h4>해시 함수의 활용</h4>
    <ul>
        <li>블록체인: 비트코인 및 기타 암호화폐에서 데이터의 ‘무결성’을 보장하고 ‘체인’을 연결하는데 사용</li>
        <li>디지털 서명: 데이터 인증 및 무결성 확인</li>
        <li>암호화 저장: 중요한 데이터를 안전하게 저장</li>
        <li>데이터 무결성 검증: 파일 다운로드 및 전송 중 데이터 손상 여부 확인</li>
    </ul>

    <h3>SHA-256 알고리즘 작동 과정</h3>

    <ul>
        <li><strong>1. 입력 데이터 준비</strong>: 입력 받은 임의의 길이의 데이터는 고정된 크기(512비트 블록)로 처리되며, 필요한 경우 패딩(padding)을 통해 데이터를
            맞춘다.
        </li>
        <li><strong>2. 패딩</strong>: 입력 데이터를 512비트 블록으로 나누기 위해 패딩을 추가한다.</li>
        <li><strong>3. 초기 해시 값 설정</strong>: 8개의 32비트 초기 해시 값을 정의한다.</li>
        <li><strong>4. 메시지 처리</strong>: 입력 데이터는 512비트 블록 단위로 처리된다.</li>
        <ul>
            <li><strong>(a) 메시지 스케줄 생성</strong> => 각 512 비트 블록은 32비트 단위로 나뉘며, 한 블록 당 16개의 워드(word)로 시작한다.</li>
            <ul>
                <li>워드: 비트 단위(정보 표현)</li>
                <li>추가적으로 48개의 워드 생성 => 총 64개의 워드가 생성된다.</li>
                <li>새로운 워드는 이전 워드의 XOR 및 시프트 연산으로 생성된다.</li>
            </ul>
            <li><strong>(b) 해시 압축 함수(라운드 연산)</strong> => 초기 해시 값과 64개의 워드 그리고 라운드 상수(64개의 고정된 32비트 상수 값)이 Round
                function의 인자 값으로 들어가게 된다.</li>
            <ul>
                <li>라운드 상수: 소수(2~311)의 세제곱근의 소수점 부분을 32비트로 변환</li>
                <li>Round Function: 메시지 블록을 처리하여 해시 값을 계산하는 핵심 연산</li>
                <li>초기 해시 값과 메시지 워드, 상수 값 등을 조합하여 새로운 해시 값을 생성하는 과정을 64번 반복한다.</li>
            </ul>
        </ul>

        <h4>최종 출력</h4>
        <ul>
            <li><strong>최종 해시 값 갱신</strong> => 라운드가 끝난 후 a, b, c, d, e, f, g, h 값을 초기 해시 값에 추가한다.</li>
            <li>모든 블록 처리가 완료되면, 초기 해시값을 연결하여 256비트(32바이트)의 최종 해시 값을 생성한다.</li>
            <li>초기 해시 값들은 64번의 Round를 거친 후 나오게 된다.</li>
        </ul>

        <h3>해시 - 비트코인</h3>

        <h4>블록 정보(블록 해시 값 생성 인자)</h4>
        <ul>
            <li>이전 블록 해시 값</li>
            <li>머클 루트: 블록 내 모든 트랜잭션의 요약 값</li>
            <li>타임스탬프</li>
            <li>난이도 목표(해시레이트)</li>
            <li>논스: 작업 증명을 완료하기 위해 반복적으로 변경된 값</li>
        </ul>

        <p>=> 위의 데이터를 결합하여 SHA-256 해시 함수를 두 번 적용해서 블록 해시 값을 생성한다.</p>
        <p>=> Block Hash = SHA256(SHA256(Block Header))</p>

        <p>블록 해시의 역할을 블록 간 연결성을 유지하고, 변경된 데이터를 탐지한다.</p>

        <h3>작업 증명</h3>
        <ul>
            <li>비트코인 네트워크에서는 채굴자가 블록체인의 새로운 블록을 연결하기 위해서는 작업 증명(PoW)라는 해시 퍼즐을 풀어야 한다.</li>
        </ul>

        <h4>작업 증명 해시 함수의 입력 값</h4>
        <ul>
            <li>버전</li>
            <li>이전 블록 해시</li>
            <li>머클 루트</li>
            <li>타임스탬프</li>
            <li>난이도 목표</li>
            <li>논스: 이것을 계속 변경한다</li>
        </ul>

        <p>=> 위의 입력 값들 중에서 논스, 타임 스탬프, 머클 루트가 해시 퍼즐을 어렵게 만드는 요인들이다.</p>

        <h3>트랜잭션 ID</h3>
        <ul>
            <li>블록에 들어가는 각 트랜잭션에는 ‘트랜잭션의 변경 여부’를 확인하고, 무결성을 보장하기 위한 트랜잭션 ID값이 존재한다.</li>
        </ul>

        <h4>트랜잭션 데이터</h4>
        <ul>
            <li>입력, 출력, 금액 등이 포함돼 있다.</li>
        </ul>

        <h4>머클 트리</h4>
        <ul>
            <li>블록에 포함된 모든 트랜잭션을 요약하며, 데이터 검증 및 효율적인 검색을 가능하게 해주는 기술</li>
        </ul>

        <h3>비트코인 주소 생성</h3>
        <ul>
            <li>비대칭키 암호화를 기반으로 생성, 비대칭키 암호화에서는 공개키와 비밀키가 사용된다.</li>
            <li>비트코인 주소는 공개 키를 SHA-256과 RIPEMD-160으로 해싱한 값으로 생성된다.</li>
        </ul>

        <h3>디지털 서명</h3>
        <ul>
            <li>트랜잭션의 무결성 보장, 소유권 증명하는데 핵심적인 역할을 함, 이 과정에서 쓰이는 것이 해시 함수이다.</li>
        </ul>

        <h4>디지털 서명 역할</h4>
        <ul>
            <li>트랙잭션 데이터 해싱: 트랜잭션 데이터의 해시 값을 서명한다.</li>
            <li>서명 생성: 개인 키로 해시 값을 서명한다.</li>
            <li>서명 검증</li>
        </ul>

        <h3>암호학의 역사</h3>

        <h4>컴퓨터 시대의 암호화</h4>
        <ul>
            <li>1990년대에 양자암호학의 등장</li>
            <li>암호 화폐에도 암호 기술이 많이 사용됨</li>
            <ul>
                <li>해시 함수, 공개 키 암호화, 디지털 서명과 같은 다양한 암호화 기술을 사용하며, 블록체인에 저장된 데이터의 ‘일관성’을 보호하고 거래를 ‘인증’하는 데 사용한다.</li>
                <li>타원곡선 전자서명 알고리즘(Elliptical Curve Digital Signature Algorithm, ECDSA)는 블록체인에 기록된 자산을 정당한 ‘소유주’만이
                    사용할 수
                    있도록 보장한다.</li>
            </ul>
        </ul>

        <h3>대칭키 암호화 & 비대칭키 암호화</h3>

        <h4>대칭키 암호화</h4>
        <ul>
            <li>암호화 및 복호화를 할 때 동일한 키를 사용하는 방식 => 여러 사용자 사이에 공유된 단 하나의 키를 기반으로 동작한다.</li>
        </ul>

        <h4>대칭키 암호 방식 동작 원리</h4>
        <ul>
            <li>키 생성: 대칭키(비밀 키)를 생성한다. 이 키는 암호화 & 복호화에 모두 사용한다.</li>
            <li>암호화: 평문 데이터를 입력받아 비밀 키를 사용하여 암호문으로 변환한다.</li>
            <li>전송: 암호문은 안전하지 않은 네트워크를 통해 수신자에게 전송된다. : 비밀 키를 아는 사람만 암호문을 복호화 할 수 있다.</li>
            <li>복호화: 수신자가 동일한 비밀 키를 사용하여 암호문을 평문으로 복호화한다.</li>
        </ul>

        <h4>비대칭키 암호화</h4>
        <ul>
            <li>공개키와 개인키를 한 쌍으로 사용하는 암호화 방식이다.</li>
        </ul>

        <h4>공개키와 개인키가 만들어지는 과정</h4>
        <ul>
            <li>공개키를 통해 암호화되고, 개인키로만 복호화 할 수 있다.</li>
        </ul>

        <!-- 2/5 -->

        <section id="bitcoin concept">
            <h2>Before going in…</h2>
        </section>

        <ul>
            <li>비트코인은 ‘블록체인 기술’을 실현한 최초의 사례</li>
        </ul>

        <h2>Block</h2>
        <ul>
            <li>헤더와 바디로 이루어져 있으며, 각 부분은 고유한 역할을 가지고 있다.</li>
        </ul>

        <h3>블록 헤더(Header)</h3>
        <ul>
            <li>블록에 대한 ‘메타데이터’를 포함하고 있으며, 블록의 고유한 ‘식별자’ 역할을 한다. 크기는 ‘80바이트’로 고정되어 있다.</li>
        </ul>

        <h4>주요 구성 요소</h4>
        <ul>
            <li>이전 블록 해시(Previous Block Hash)
                <ul>
                    <li>이전 블록의 해시 값으로, 블록 간 연결성을 제공한다.</li>
                    <li>체인 형성, 블록체인의 무결성 보장</li>
                </ul>
            </li>
            <li>머클 루트(Merkle Root)
                <ul>
                    <li>모든 트랜잭션의 해시를 결합하여 생성된 트리의 ‘루트 해시’값이다.</li>
                    <li>블록 내 모든 트랜잭션이 변경되지 않았음을 ‘증명’한다.</li>
                </ul>
            </li>
            <li>타임스탬프(Timestamp)
                <ul>
                    <li>블록이 생성된 시간</li>
                    <li>UNIX 타임스탬프 형식(초 단위)으로 저장된다.(1970/1/1 00:00:00 UTC 부터 경과한 시간을 초 단위의 정수로 표현)</li>
                </ul>
            </li>
            <li>난이도 타겟(Difficulty Target)
                <ul>
                    <li>현재 블록 생성 ‘난이도’를 나타낸다.</li>
                    <li>네트워크의 작업 증명 목표를 정의한다.</li>
                </ul>
            </li>
            <li>논스(Nonce)
                <ul>
                    <li>작업 증명에서 정답을 찾기 위해 변경되는 값</li>
                    <li>정답 블록 해시를 찾기 위해 채굴자가 반복적으로 시도한다.</li>
                </ul>
            </li>
            <li>버전(Version)
                <ul>
                    <li>블록이 사용하고 있는 비트코인 프로토콜의 버전 정보</li>
                </ul>
            </li>
        </ul>

        <h3>블록 바디(Body)</h3>
        <ul>
            <li>블록에 포함된 ‘트랜잭션 데이터’를 저장한다</li>
        </ul>

        <h4>주요 구성 요소</h4>
        <ul>
            <li>코인베이스 트랜잭션(Coinbase Transaction)
                <ul>
                    <li>블록을 생성한 채굴자에게 ‘보상이 지급되는 트랜잭션’</li>
                    <li>항상 블록의 ‘첫 번째’ 트랜잭션으로 포함된다</li>
                </ul>
            </li>
            <li>일반 트랜잭션(Transaction)
                <ul>
                    <li>블록에 포함된 ‘모든 비트코인 전송 기록’</li>
                    <li>트랜잭션 개수는 ‘네트워크 상태’와 ‘트랜잭션 용량’에 따라 달라진다.</li>
                </ul>
            </li>
            <li>트랜잭션 데이터 구조
                <ul>
                    <li>입력(Input)과 출력(Output)으로 구성, 각 트랜잭션의 상세한 내용이 포함</li>
                </ul>
            </li>
            <li>현재 비트코인은 한 블록 당 최대 4MB의 데이터를 처리할 수 있다.
                <ul>
                    <li>블록 헤더: 80바이트</li>
                    <li>트랜잭션 데이터: 나머지 공간(1MB or 4MB) 차지</li>
                </ul>
            </li>
        </ul>

        <h2>트랜잭션(Transaction)</h2>
        <ul>
            <li>비트코인 블록체인의 ‘트랜잭션 구조’는 송금 요청을 ‘기록’하고 ‘검증’하기 위해 사용되는 데이터 구조다. 트랜잭션은 크게 ‘입력’과 ‘출력’으로 구성된다.</li>
        </ul>

        <h3>트랜잭션의 주요 구성 요소</h3>
        <ul>
            <li>버전(Version)
                <ul>
                    <li>트랜잭션 형식 정의(숫자 필드)</li>
                    <li>현재 버전은 2 or 1, 추후의 업데이트를 위해 사용</li>
                    <li>크기: 4바이트</li>
                </ul>
            </li>
            <li>입력(Input) => 입력은 트랜잭션이 사용하는 ‘이전 트랜잭션의 출력(UTXO: Unspent Transaction Output)’을 참조한다. 입력은 송신자의 ‘서명’이
                포함된
                정보다.
                <ul>
                    <li>트랜잭션 해시(Transaction Hash)
                        <ul>
                            <li>현재 트랜잭션이 참조하는 이전 트랜잭션의 ‘해시 값’</li>
                            <li>크기: 32바이트</li>
                        </ul>
                    </li>
                    <li>출력 인덱스(Output Index)
                        <ul>
                            <li>참조하는 트랜잭션에서 어떤 출력(0으로 시작하는 인덱스)을 사용하는지 나타낸다. => 지출할 UTXO</li>
                            <li>크기: 4바이트</li>
                        </ul>
                    </li>
                    <li>스크립트 길이(Script Length)
                        <ul>
                            <li>잠금 해제 스크립트(Unlocking Script, ScriptSig)의 길이를 나타낸다.</li>
                            <li>크기: 가변</li>
                        </ul>
                    </li>
                    <li>스크립트 서명(ScriptSig)
                        <ul>
                            <li>이전 트랜잭션 출력의 ‘소유권’을 ‘증명’하기 위한 ‘서명’과 ‘공개키’로 구성된 스크립트</li>
                            <li>‘공개키’와 ‘디지털 서명’이 포함</li>
                        </ul>
                    </li>
                    <li>시퀀스 번호(Sequence Number)
                        <ul>
                            <li>트랜잭션이 취소 or 수정될 가능성을 나타내는 필드, 거의 사용 X</li>
                            <li>크기: 4바이트</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>출력(Output) => 수신자에게 전달되는 비트코인 정보, 한 트랜잭션은 ‘여러 개의 출력’을 가질 수 있다.
                <ul>
                    <li>출력 금액(Value)
                        <ul>
                            <li>해당 출력에 포함된 비트코인 금액을 나타낸다.</li>
                            <li>단위: 사토시</li>
                            <li>크기: 8바이트</li>
                        </ul>
                    </li>
                    <li>스크립트 길이(Script Length)
                        <ul>
                            <li>잠금 스크립트(Locking Script, ScriptPubKey)의 길이를 나타낸다.</li>
                            <li>크기: 가변</li>
                        </ul>
                    </li>
                    <li>잠금 스크립트(ScriptPubKey)
                        <ul>
                            <li>비트코인을 잠금(수신자의 주소를 설정)하는 스크립트(ex: 공개키 해시)</li>
                            <li>일반적으로 P2PKH(Pay-to-Public-Key-Hash)스크립트 형식을 사용하며, 수신자의 주소를 포함한다.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>트랜잭션 카운터(Transaction Counter)
                <ul>
                    <li>트랜잭션이 포함된 ‘입력’과 ‘출력’의 개수를 기록</li>
                    <li>각 트랜잭션마다 ‘입력 개수’와 ‘출력 개수’를 별도로 저장, 트랜잭션 크기 빠르게 파악</li>
                    <li>크기: 가변(1바이트 이상, 비트코인 직렬화 규칙에 따라 다름)</li>
                </ul>
            </li>
            <li>잠금 시간(Lock Time => 미래의 특정 시점에 거래를 실행할 수 있도록 예약하는 기능
                <ul>
                    <li>해당 트랜잭션이 유효해지는 조건</li>
                    <li>특정 ‘블록 높이’ 또는 ‘타임스탬프’가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효하다.</li>
                    <li>크기: 4바이트</li>
                </ul>
            </li>
        </ul>

        <h3>트랜잭션 흐름의 요약</h3>
        <ul>
            <li>송신자는 ‘입력’에서 ‘이전 트랜잭션 출력(UTXO)’을 참조한다.</li>
            <li>해당 입력에 ‘개인 키’로 디지털 서명을 생성하여 서명 스크립트(ScriptSig)에 포함한다.</li>
            <li>송신자는 비트코인을 보낼 수신자의 주소를 ‘출력’에 지정하며, 잠금 스크립트(ScriptKey)를 생성한다.</li>
            <li>수신자는 잠금 스크립트를 해제하기 위해 자신의 ‘공개키’와 ‘서명’을 제공해야 한다.</li>
            <li>네트워크 노드는 ‘입력’과 ‘출력’의 ‘검증’을 수행하여 트랜잭션이 올바른지 확인한다.</li>
        </ul>

        <h2>비트코인 자금 출처 관리 시스템 - UTXO</h2>
        <ul>
            <li>“아직 사용 안 된 상태의 비트코인은 보관되고, 사용한 상태의 비트코인은 사용된 것으로 기록에 남는다.”</li>
        </ul>

        <h3>UTXO(Unspent Transaction Output)</h3>
        <ul>
            <li>이전 트랜잭션에서 생성되었지만 ‘아직 소비되지 않은 출력’</li>
            <li>비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 ‘기본 단위’</li>
        </ul>

        <h4>UTXO의 역할</h4>
        <ul>
            <li>잔고 관리: 사용자가 보유한 비트코인의 총량은 해당 사용자가 소유한 UTXO의 합계로 계산된다.</li>
            <li>트랜잭션 검증: UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할 수 없으므로 이중 지불을 방지한다.</li>
            <li>이중 지불: 블록체인에서 한 번 사용된 암호화폐를 다시 다른 곳에서 사용하는 것을 시도하는 행위</li>
        </ul>

        <h4>UTXO의 동작 방식</h4>
        <ul>
            <li>생성:
                <ul>
                    <li>트랜잭션의 출력으로 새 UTXO가 생성된다.</li>
                    <li>이 출력은 특정 비트코인 주소로 잠겨 있으며, 해당 주소의 소유자만 이 UTXO를 소비할 수 있다.</li>
                </ul>
            </li>
            <li>소비:
                <ul>
                    <li>트랜잭션의 입력(Input)은 기존 UTXO를 참조하여 소비한다.</li>
                    <li>소비된 UTXO는 더 이상 유효하지 않으며, 새로운 UTXO가 생성된다.</li>
                </ul>
            </li>
        </ul>

        <h4>UTXO의 구조</h4>
        <ul>
            <li>금액: 비트코인 양</li>
            <li>소유자 정보: 트랜잭션 스크립트(P2PKH) 형태로 저장된 소유자 정보</li>
            <li>트랜잭션 ID: UTXO를 생성한 트랜잭션의 고유 식별자(TxID)</li>
            <li>출력 인덱스: 트랜잭션에서 UTXO가 몇 번째 출력인지 확인하는 번호</li>
        </ul>

        <h4>UTXO와 트랜잭션의 관계</h4>
        <ul>
            <li>트랜잭션 입력: 기존 UTXO를 참조하여 해당 금액을 소비한다.</li>
            <li>트랜잭션 출력: 새로운 UTXO를 생성하여 수신자 또는 잔돈으로 보낸다.</li>
            <li>이중 지불 방지: 이미 소비된 UTXO는 다시 사용할 수 없으므로 ‘동일 금액을 반복 사용하려는 시도’를 방지한다.</li>
        </ul>

        <h4>UTXO의 저장 및 관리</h4>
        <ul>
            <li>잔고 계산: 잔고는 보유한 모든 잔돈 UTXO의 합계(SUM)로 계산된다.</li>
            <li>UTXO 세트: 사용되지 않은 출력 목록(UTXO 세트)을 유지한다.</li>
            <li>저장소 요구 사항: 사용되지 않은 출력이 누적되어 UTXO 세트의 크기가 증가한다. 이는 저장소와 처리 부담을 증가시킨다.</li>
        </ul>

        <h4>UTXO의 장점, 단점</h4>
        <ul>
            <li>장점
                <ul>
                    <li>보안성</li>
                    <li>병렬 처리 가능</li>
                </ul>
            </li>
            <li>단점
                <ul>
                    <li>복잡한 잔돈 관리</li>
                    <li>저장소 부담</li>
                </ul>
            </li>
        </ul>

        <h4>UTXO 컨텐츠와 연계되는 설명</h4>
        <ul>
            <li>스크립트
                <ul>
                    <li>UTXO를 소비하려면 ‘스크립트 언어’(OP Code)를 통해 ‘트랜잭션의 유효성’을 확인해야 하며, 이 연산자 코드가 그 과정을 담당하게 된다.</li>
                </ul>
            </li>
            <li>연산자 코드
                <ul>
                    <li>OP_CHECKSIG: 공개 키와 서명을 인자로 받아 트랜잭션 ‘해시 서명의 유효성’을 검증한다.</li>
                    <li>OP_EQUAL: 입력 값들이 같으면 1, 아니면 0 리턴</li>
                    <li>OP_DUP: 스택의 최상위 항목을 복제한다.</li>
                    <li>OP_HASH160: SHA-256 해싱, RIPEMD-160으로 해싱한다.</li>
                    <li>OP_VERIFY: 최상위 스택 값이 ‘참’이 아니면 트랜잭션을 ‘유효하지 않은 것’으로 표시</li>
                    <li>OP_EQUALVERIFY: OP_EQUAL과 동일하나, 나중에 OP_VERIFY를 실행</li>
                    <li>OP_CHECKMULTISIG: 첫 번째 서명을 인자로 받아 일치하는 키를 찾을 때까지 각 공개 키와 비교, 같으면 1, 아니면 0 리턴</li>
                </ul>
            </li>
        </ul>

        <h2>머클 루트</h2>
        <ul>
            <li>머클 트리(Merkel Tree)
                <ul>
                    <li>여러 데이터에 대해 단계적으로 해시 함수를 적용하여 최종적으로 ‘머클 루트’라는 하나의 ‘최상단 해시값’을 생성하는 데이터 구조</li>
                    <li>머클 트리는 블록체인에서 ‘데이터의 무결성을 보장’하고 ‘위변조를 방지’하기 위해 사용된다.</li>
                </ul>
            </li>
            <li>트랜잭션 해시값: 트랜잭션 데이터 전체를 두 번 SHA-256 해싱한 결과</li>
            <li>머클 루트의 중요성
                <ul>
                    <li>블록 헤더: 머클 루트는 블록 헤더에 저장, 블록체인 네트워크에서 작업 증명을 수행할 때 중요한 역할을 한다.</li>
                    <li>경량화된 노드(Light Node): 전체 블록체인을 다운로드하지 않고 머클 루트를 사용해 특정 트랜잭션의 유효성을 검증하는 노드</li>
                    <li>변조된 머클 루트가 헤더에 반영</li>
                    <li>연쇄적 변화 발생</li>
                </ul>
            </li>
        </ul>

        <!-- 2/6 -->

        <section id="distributed ledger">
            <h1>분산 원장</h1>
            <p>원장(Ledger)은 ‘거래’, ‘소유권’, ‘자산’ 등 다양한 데이터를 기록하고 관리하는 시스템입니다.</p>
        </section>

        <h2>중앙 집중형 원장</h2>
        <ul>
            <li>데이터가 중앙 기관에 의해 관리</li>
            <li>단일 장애점(Single Point of Failure) 존재</li>
            <li>효율성은 높지만 투명성 부족</li>
        </ul>

        <h2>분산 원장</h2>
        <ul>
            <li>여러 노드(참여자)에 데이터를 분산 저장</li>
            <li>변경 불가능성 및 높은 투명성</li>
            <li>탈중앙화된 방식</li>
        </ul>

        <h3>분산 원장의 종류</h3>
        <ul>
            <li>퍼블릭 분산원장</li>
            <li>프라이빗 분산원장</li>
            <li>컨소시엄 분산원장</li>
        </ul>

        <h2>분산 원장 기술 (DLT)</h2>
        <p>P2P 네트워크에서 데이터를 분산 저장하고 관리하는 기술</p>
        <ul>
            <li>합의 알고리즘</li>
            <li>암호화</li>
            <li>노드 동기화</li>
        </ul>

        <h2>노드(Node)</h2>
        <p>블록체인 네트워크에 연결된 컴퓨터</p>
        <h3>노드의 역할</h3>
        <ul>
            <li>데이터 저장</li>
            <li>데이터 검증</li>
            <li>네트워크 연결 및 데이터 전파</li>
            <li>합의 참여</li>
        </ul>

        <h3>노드 유형</h3>
        <ul>
            <li>풀 노드(Full Node)</li>
            <li>라이트 노드(SPV)</li>
            <li>마이닝 노드</li>
            <li>검증 노드(Validator Node)</li>
            <li>아카이브 노드</li>
        </ul>

        <h2>합의 알고리즘</h2>
        <h3>PoW(Proof of Work)</h3>
        <ul>
            <li>연산 작업을 통해 합의</li>
            <li>높은 보안성 제공</li>
            <li>에너지 소비가 많음</li>
        </ul>

        <h3>PoS(Proof of Stake)</h3>
        <ul>
            <li>지분을 기반으로 블록 생성</li>
            <li>에너지 효율성 높음</li>
            <li>지분 집중화 문제 가능성</li>
        </ul>

        <h3>DPoS(Delegated Proof of Stake)</h3>
        <ul>
            <li>대표자를 선출하여 블록 검증</li>
            <li>민주적 구조</li>
            <li>중앙화 가능성 존재</li>
        </ul>

        <h2>채굴 과정</h2>
        <ul>
            <li>트랜잭션 생성 및 전파</li>
            <li>트랜잭션 수집</li>
            <li>블록 템플릿 생성</li>
            <li>작업 증명(PoW)</li>
            <li>블록 검증 및 전파</li>
            <li>블록체인에 추가</li>
        </ul>

        <!-- 2/7 -->

        <section id="ethereum">
            <h1>Before going in…</h1>
        </section>

        <p>이더리움은 ‘프로그래밍이 가능한 블록체인’의 ‘선구자’ 역할을 한 블록체인이다.</p>

        <h2>이더리움 탄생 배경</h2>
        <h3>튜링 완전성(Turing Completeness)</h3>
        <p>튜링 완전성이란 특정 시스템이 ‘튜링 기계(Turing Machine)와 같은 계산 능력을 가졌음을 의미한다.</p>
        <ul>
            <li>어떠한 계산 가능한 문제도, 적절한 알고리즘과 충분한 리소스(시간과 메모리)가 주어진다면 해결할 수 있다.</li>
        </ul>

        <h3>튜링 기계</h3>
        <p>앨런 튜링이 제안한 ‘가상의 계산 모델’로, 현대 컴퓨터의 계산 가능성을 설명하는 기초 개념이다.</p>
        <ul>
            <li>무한한 길이의 테이프(데이터 저장소 역할)</li>
            <li>읽기/쓰기 헤드(테이프의 데이터를 읽고 쓸 수 있음)</li>
            <li>상태 머신(현재 상태와 입력에 따라 동작을 결정하는 규칙 집합)</li>
        </ul>

        <h3>튜링 완전성의 조건</h3>
        <ul>
            <li>임의의 조건 분기(Conditional Branching)</li>
            <li>임의의 루프(Arbitrary Loops)</li>
        </ul>

        <h3>튜링 완전성과 블록체인</h3>
        <p>이더리움은 EVM을 통해 튜링 완전성을 지원하여 복잡한 스마트 계약을 작성할 수 있다.</p>
        <ul>
            <li>가스 제한을 두어 무한 루프를 방지</li>
        </ul>

        <h2>비탈린 부테린</h2>
        <p>비탈린은 비트코인이 단순한 디지털 화폐로 사용되는 한계를 느끼고 이더리움을 개발했다.</p>

        <h2>이더리움의 핵심 목표</h2>
        <h3>스마트 계약(Smart Contract)</h3>
        <p>자동 실행되는 계약으로, 특정 조건이 충족되면 실행된다.</p>

        <h3>Dapps</h3>
        <p>이더리움 네트워크에서 다양한 애플리케이션을 실행할 수 있는 탈중앙화 앱(Dapp)을 제공한다.</p>

        <h2>비트코인 vs 이더리움</h2>
        <h3>주소 형식</h3>
        <ul>
            <li><strong>비트코인:</strong> SHA256 + RIPMD-160, BASE58 인코딩</li>
            <li><strong>이더리움:</strong> Keccak256, 16진수(40자), “0x”로 시작</li>
        </ul>

        <h2>이더리움 - 어카운트 기반 모델(Account-based)</h2>
        <h3>계정의 종류</h3>
        <ul>
            <li><strong>외부 소유 계정(EOA):</strong> 개인이 소유한 계정, 개인키로 제어</li>
            <li><strong>스마트 계약 계정(CA):</strong> 특정 코드가 배포된 계정</li>
        </ul>

        <h3>Nonce</h3>
        <p>트랜잭션 순서를 관리하고 재생 공격 방지를 위한 고유 값</p>

        <h2>보안</h2>
        <p>이더리움은 nonce와 체인 ID를 통해 재생 공격을 방지한다.</p>

        <h2>EVM(Ethereum Virtual Machine)</h2>
        <p>이더리움 네트워크에서 스마트 계약을 실행하는 가상 환경</p>
        <h3>바이트코드 동작방식</h3>
        <ul>
            <li>스택 기반 아키텍처</li>
            <li>Opcode를 이용하여 연산</li>
        </ul>

        <h3>EVM의 보안성과 가스(Gas)</h3>
        <ul>
            <li>보안 격리(Sandboxing)로 스마트 계약 충돌 방지</li>
            <li>가스 비용을 통해 네트워크 리소스 낭비 방지</li>
        </ul>

        <h2>스마트 컨트랙트(Smart Contract)</h2>
        <p>자동화된 계약 실행 프로토콜</p>
        <h3>장점</h3>
        <ul>
            <li>보안성</li>
            <li>신뢰성</li>
            <li>공평함</li>
            <li>효율성</li>
        </ul>
        <h3>단점</h3>
        <ul>
            <li>수정 불가능</li>
            <li>외부 정보를 직접 가져올 수 없음(오라클 필요)</li>
        </ul>

        <div class="below"></div>

        <div class="below_box">
            &copy; 2025 GiHyeon's Blog
            <p>All rights reserved</p>
        </div>

</body>

</html>